# Simon Project

In this exercise we will reproduce the Simon game. In this game, we have to follow a sequence of colors that are generated randomly and will continue to repeat a sequence until you fail to successfully follow it. The goal of this exercise if for you to get acquatinted with jQuery, thus, everything that you do in this work should be using jQuery instead of plain javascript.


## Instructions

- Create a js file to host your code and link it with the html.
- Add _jQuery_ to your website
- In your js file, create a method called **nextSequence**. This function should generate a new random number between 0 and 3 and store it in a variable. (You can test this by using the console.log method to see the created values)
- At the top of our file, as a global variable, create an array with the values **"red", "blue", "green", "yellow"**. These are going to be the pointers to the buttons that the random number is creating.
- Create an array as a global variable that will be storing the pattern as we are creating it.
- Inside of our method, create a variable that will store the corresponding value of the above created array using the randomly generated index.
- Insert the value just extracted into our global array that contains the game pattern. Log the array to the console to verify that it is working.
- Using jQuery, select the button with the id that was previously selected. As you may have observed, the values of the global array, match the id of the div elements that in the UI.
    - HTML tag to add jQuery
```html
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
```
- Once you have selected the object, add a blinking behavior to it, to signal that this has been selected. (**Tip:** google the _fadeIn/fadeOut_ behavior)

We will now add some sounds to every button. In the provided code you have sounds for all of them. For now we will link them based on their colors.

### Animation

Now that the response behavior has been setup, we need to attach the event handler to a call to this method using jQuery. 
- Add a listener for the click event to all the buttons. In the handler method, create a variable to store the id of the selected button.
- Add another global variable that should store the sequence of buttons that the user has clicked.
- Add the clicked button to the array we just created above. Display the array in the console so you can verify that they are registering properly.
- Play the sound of the corresponding button as we did in the nextSequence method. (Tip: if you didn't do so earlier, create a function for playing the sounds that receives as a parameter the color that it should play)
- Create a new method called **animatePress**. This method should use the _css_ **pressed** class (already in the css file) to further hint the selection of the button. This method should take the current color as a parameter to properly animate the corresponding button. (**Tip:** Use the _addClass/removeClass_ method and a 100ms timeout to create this behavior.)

### Game mechanics

Let's deal with the beginning of the game. Until now, we have created the method that will create the random sequence we have to follow, and the listeners for us to deal when we press into any of the buttons. Now it is time to deal with the start of the game
- Add a keyboard listener, the handler for this listener should call the **nextSequence** method to start the random generation of the game.
- In order to keep track of our progress on the game, we will add a **level** variable. This will start at zero and will progress every time we are able to recreate the sequence generated so far.
- Once the game starts, the content of the **h1** tag that starts with the "_Press A Key to Start_" should be replaced with the level that we are currently at (e.g. Level 0). As stated early, this label should be refreshed every time we advance on the sequence, so we also have to update the **h1** tag everytime a new element is added to the sequence in the nextSequence method.

The next step is to check if the sequence input by the user matches the one generated by the game, thus we have to device a way to check if we were successful or not.
- Create a new method called **checkAnswer**, this method will take an input parameter that will tell us in which level we currently are.
- Call the _checkAnswer_ method right after we finish the animation of the button being pressed in the click handler method. Remember that you have to pass the parameter of the current level the user has entered. That is, when a sequence is being pressed by the user we will be verifying the entry one at the time.
- Inside of the _checkAnswer_ method, check if the value of the received index matches the value on the same index at the generated sequence. If the values match log a "_success"_ message, else "_wrong_"
- Use these logs in the console to check if the logic of your game is working as expected.
- If the user succeeds verify if the whole sequence has been verified.
- To continue the sequence, when all the previous sequence has been verified, call the next sequence method after a delay of 1000 ms.
- Whenever the _nextSequence_ method is called, we need to reset the **userClickedPattern** to an empty array so we can verify again the whole sequence

Lets improve the UX. Lets put some feedback on the case when the user fails.
- When the user fails, play the "_wrong_" sound that is in the sounds folder. Also use the gameOver style in the background to further signal the end of the game, we will keep this style for 200 miliseconds. Finally, change the h1 content to "_Game over, Press Any Key to Restart_"
- Create a method to **restart** the game, and make sure you call it after the game over message. Inside this function reset the value of the level, the game pattern .
---
Observe that even though it all seems to be completd, there is a problem. If you press any key at any time, you will restart your game all the time. To solve this problem, we will use a guardian variable. 
- Add a new global variable called **started** and initialize it with a _false_ value. When the game starts, we will change the value to _true_.
- When we start the game in the keypressed event, we will check if the flag is set to _true_, if it is, we will do nothing, else we will start the game.
- We have to reset the value to false when the game is finished in our **startOver** method.

----
[Sample solution](https://gist.github.com/gcastillo56/fb4933f17ca90e3c304f809b9f2721b0)